/*
 * @file    clock_config.c
 * @author  Enrique Emanuel Decima
 * @brief   Implementacion del driver de motor paso a paso
 *
 */

/**
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */

#include "main.h"
#include "motorpap.h"
#include "gpio.h"

uint32_t period_ms = 100;

void MotorPAP_InitTIM(uint32_t clock_Speed_MHz, TIM_HandleTypeDef *htim)
{

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim->Init.Prescaler = clock_Speed_MHz;
  htim->Init.CounterMode = TIM_COUNTERMODE_UP;
  htim->Init.Period = 65535;
  htim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim->Init.RepetitionCounter = 0;
  htim->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(htim) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(htim, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(htim, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }

}

void MotorPAP_Init(MotorPAP_HandleTypeDef* hmot, TIM_HandleTypeDef *htim, GPIO_TypeDef* Port,uint16_t PINA, uint16_t PINB, uint16_t PINC, uint16_t PIND){
	hmot->htim = htim;
	hmot->Port = Port;
	hmot->Motor_Pin_A = PINA;
	hmot->Motor_Pin_B = PINB;
	hmot->Motor_Pin_C = PINC;
	hmot->Motor_Pin_D = PIND;
	hmot->Angle = 0;

	GPIO_EnableCLK(Port);
	GPIO_InitPin(Port, PINA, GPIO_MODE_OUTPUT);
	GPIO_InitPin(Port, PINB, GPIO_MODE_OUTPUT);
	GPIO_InitPin(Port, PINC, GPIO_MODE_OUTPUT);
	GPIO_InitPin(Port, PIND, GPIO_MODE_OUTPUT);

	//MotorPAP_InitTIM(16, htim);
}

void MotorPAP_StepForward(MotorPAP_HandleTypeDef hmot){
	GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_STATE_HIGH);
	GPIO_WritePin(GPIOA, GPIO_PIN_2, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_STATE_LOW);
	HAL_Delay(period_ms);
	GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_2, GPIO_STATE_HIGH);
	GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_STATE_LOW);
	HAL_Delay(period_ms);
	GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_2, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_STATE_HIGH);
	GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_STATE_LOW);
	HAL_Delay(period_ms);
	GPIO_WritePin(GPIOA, GPIO_PIN_1, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_2, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_STATE_LOW);
	GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_STATE_HIGH);
}

void MotorPAP_OneRev(MotorPAP_HandleTypeDef hmot, MotorPAP_Direction direction){
	for(int i=0;i<STEPS_FOR_REV;i++){
		MotorPAP_StepForward(hmot);
	}
}

